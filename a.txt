#include "stdafx.h"
#include <windows.h>
#include <curses.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>


#define BUFFSIZE 1024		/*文字列を取得するときに使用*/

void CSV2Array(const char* fileName);	//csv読み込み関数
void graph(int x, int y);				//ｘ軸ｙ軸書き込み関数

struct tmp {		//構造体
	int year;
	int month;
	double temp;
};

int main()
{

	// 初期化
	if (initscr() == NULL) {
		return 1;
	}

	char str[BUFFSIZE];
	GetPrivateProfileString("section1", "key1", "none", str, sizeof(str), "C:\data1.ini");	//iniファイル読み込み
	printf("取得した文字列：%s\n", str);		//イにファイルｙ見込みのデバッグ
	erase();
	//特殊キー
	noecho();
	cbreak();
	keypad(stdscr, TRUE);
	//ここまでキー判定
	CSV2Array(str); //配列格納

	endwin();

	return 0;
}

void CSV2Array(const char* fileName) {

	FILE* fp;
	char s[BUFFSIZE];
	char s1[BUFFSIZE];
	char s2[BUFFSIZE];
	char s3[BUFFSIZE];
	char t1[BUFFSIZE];
	char t2[BUFFSIZE];
	char t3[BUFFSIZE];

	struct tmp late[13];//2018
	struct tmp ago[13];//2000
	double a[13];
	double b[13];

	char delim[] = ",";
	char* ctx;

	char* p1;
	int key;
	int count = 0;

	errno_t error;
	error = fopen_s(&fp, fileName, "r");

	if (error != 0)
		fprintf_s(stderr, "failed to open");
	else {
		while (fgets(s, BUFFSIZE, fp) != NULL) {						//一行ずつ読み込む
			p1 = strtok_s(s, delim, &ctx);								//,で区切った1個目

			if (5 < count && count < 18) {  //2010年の時	
				ago[count - 5].year = atoi(p1);//年を代入
				ago[count - 5].month = atoi(strtok_s(NULL, delim, &ctx));	//月を格納
				ago[count - 5].temp = atof(strtok_s(NULL, delim, &ctx));//2000での最高気温格納
																		/*printf("%d\n", ago[count - 5].year);
																		printf("%d\n", ago[count - 5].month);
																		printf("%f\n", ago[ago[count - 5].month - 1].temp);*/
			}
			else if (count > 17) {  //2018の時
				late[count - 17].year = atoi(p1);//年を代入
				late[count - 17].month = atoi(strtok_s(NULL, delim, &ctx));	//月を格納
				late[count - 17].temp = atof(strtok_s(NULL, delim, &ctx));//2018での最高気温格納
																		  /*printf("%d\n", late[count - 17].year);
																		  printf("%d\n", late[count - 17].month);
																		  printf("%f\n", late[count - 17].temp);*/
			}
			count++;
		}
		fclose(fp);

	}

	for (int w = 0; w < 12; w++) {		//小数点以下省略
		a[w] = floor(ago[w + 1].temp);
		b[w] = floor(late[w + 1].temp);

	}

	error = fopen_s(&fp, "result.csv", "w");	//result.csvに出力
	if (error != 0)
		fprintf_s(stderr, "failed to open");
	else {

		fputs("<<小数を切り捨てして表示>>\n", fp);	//上の一行に説明を書く
		fputs("<<2000年と2018年の奈良の最低気温>>\n\n", fp);	//上の一行に説明を書く
		for (int i = 1; i <= 12; i++) {


			sprintf_s(s1, BUFFSIZE, "%d年", 2010);
			sprintf_s(s2, BUFFSIZE, "%d月の最低気温 => ", i);
			sprintf_s(s3, BUFFSIZE, "%2.1f℃\n", a[i - 1]);		//最低気温と改行コード挿入

			fputs(s1, fp);
			fputs(s2, fp);
			fputs(s3, fp);
		}
		for (int i = 1; i <= 12; i++) {
			sprintf_s(t1, BUFFSIZE, "%d年", 2018);
			sprintf_s(t2, BUFFSIZE, "%d月の最低気温 => ", i);
			sprintf_s(t3, BUFFSIZE, "%2.1f℃\n", b[i - 1]);		//最低気温と改行コード挿入

			fputs(t1, fp);
			fputs(t2, fp);
			fputs(t3, fp);

		}fclose(fp);
	}
	for (int s = 0; s < 12; s++) {
		printf("%f\n", a[s]);
	}
	start_color();	// カラーの設定
	init_pair(1, COLOR_GREEN, COLOR_BLACK);	//黒みどり
	init_pair(3, COLOR_RED, COLOR_BLACK);	//黒赤
	bkgd(COLOR_PAIR(1));			// 色１をデフォルト色とする
	graph(50, 50);				//グラフ作成
	attrset(COLOR_PAIR(1));
	int x = 55;
	move(2, 75);
	addstr("2000年度");
	for (int i = 0; i < 12; i++) {		//2010年度の最高気温グラフ出力
		for (int j = 0; j < a[i]; j++) {
			move(50 - j, x);
			addstr("■");
		}
		x += 5;
	}

	//キー判定
	while ((key = getch()) != KEY_UP) {			//↑でない限り
		switch (key) {
		case KEY_LEFT:					//←キー
			erase();
			graph(50, 50);				//グラフ作成
			attrset(COLOR_PAIR(1));
			x = 55;
			for (int i = 0; i < 12; i++) {
				for (int j = 0; j < a[i]; j++) {
					move(50 - j, x);
					addstr("■");
				}
				x += 5;
			}
			move(2, 75);
			addstr("2000年度");
			break;
		case KEY_RIGHT:					//→キー
			erase();
			graph(50, 50);				//グラフ作成
			attrset(COLOR_PAIR(3));
			x = 55;
			for (int i = 0; i < 12; i++) {
				for (int j = 0; j < b[i]; j++) {
					move(50 - j, x);
					addstr("■");
				}
				x += 5;
			}
			move(2, 75);
			addstr("2018年度");
			break;
		default:
			break;
		}
	}
}


void graph(int x, int y) {				//グラフ作成関数
	attrset(COLOR_PAIR(2));
	init_pair(2, COLOR_WHITE, COLOR_BLACK);
	//int y = 50;
	//int x = 26;
	for (int i = 0; i < 45; i++) {
		mvaddstr(y - i, x, "|");
		move(y - i, x - 5);
		if (y - i == 50) {
			addstr("0");
		}
		else if (y - i == 45) {
			addstr("5");
		}
		else if (y - i == 40) {
			addstr("10");
		}
		else if (y - i == 35) {
			addstr("15");
		}
		else if (y - i == 30) {
			addstr("20");
		}
		else if (y - i == 25) {
			addstr("25");
		}
		else if (y - i == 20) {
			addstr("30");
		}
		else if (y - i == 15) {
			addstr("35");
		}
		else if (y - i == 10) {
			addstr("40");
		}
		else if (y - i == 5) {
			addstr("45");
		}
	}

	for (int i = 0; i < 70; i++) {
		mvaddstr(y, x + i, "_");
		move(y + 2, x + i);
		if (x + i == 55) {
			addstr("1");
		}
		else if (x + i == 60) {
			addstr("2");
		}
		else if (x + i == 65) {
			addstr("3");
		}
		else if (x + i == 70) {
			addstr("4");
		}
		else if (x + i == 75) {
			addstr("5");
		}
		else if (x + i == 80) {
			addstr("6");
		}
		else if (x + i == 85) {
			addstr("7");
		}
		else if (x + i == 90) {
			addstr("8");
		}
		else if (x + i == 95) {
			addstr("9");
		}
		else if (x + i == 100) {
			addstr("10");
		}
		else if (x + i == 105) {
			addstr("11");
		}
		else if (x + i == 110) {
			addstr("12");
		}

	}
	/*
	int key = getch();
	keypad(stdscr, TRUE);
	if (key == 'a') {
	endwin();
	}*/
}

